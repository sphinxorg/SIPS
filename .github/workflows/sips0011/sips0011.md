# 1. HashTree signature

> Authors: C. Kusuma
>
> License: MIT
>
> Status: Revision
>
> Based on: [sips0002](https://github.com/sphinx-core/sips/tree/main/.github/workflows/sips0002) HashTree Signature (Original)


This document revises the original SIPS-0002 specification for SPHINCS+ HashTree signatures. While the original implementation introduced Merkle tree integration for signature management, this revision introduces a compact proof protocol that eliminates the need to transmit full SPHINCS+ signatures across the network. Instead, it enables verification through cryptographic commitments bound to the signer's public key.


# 2. Background

### 1.1 Original SIPS-0002 (HashTree Signature)

The original SIPS-0002 specification implemented:

* SPHINCS+ (NIST standardized post-quantum signature scheme)
* Merkle tree construction from 4 signature parts
* Efficient signature storage and management
* Integrity verification through Merkle root comparison
* Challenge: SPHINCS+ signatures are ~7KB, making them impractical for bandwidth-constrained environments like blockchain transactions.


# 3. Core Concept

Instead of transmitting the full SPHINCS+ signature (~7KB), Alice generates a cryptographic commitment (proof) that binds together:

* The message being signed
* A timestamp (prevents replay attacks)
* A nonce (ensures uniqueness)
* The Merkle root of the signature parts
* Alice's public key

Charlie can regenerate this proof using only public information and verify it against Alice's public key.


```bash
Alice                                  Charlie
  |                                       |
  |─── Generate Key Pair ─────────────────│
  |                                       |
  |─── Sign Message ──────────────────────│
  |    • Create signature                 |
  |    • Split into 4 parts               |
  |    • Build Merkle tree                |
  |    • Store parts in LevelDB           |
  |                                       |
  |─── Generate Proof ────────────────────│
  |    • Combine: timestamp + nonce + msg |
  |    • Add merkleRoot + publicKey       |
  |    • Hash all components               |
  |                                       |
  |─── Send to Charlie ───────────────────│
  |    • Proof (32 bytes)                 |
  |    • Public Key (32 bytes)            |
  |    • Message                          |
  |    • Timestamp (8 bytes)              |
  |    • Nonce (16 bytes)                 |
  |    • Merkle Root (32 bytes)           |
  |                                       |
  |                                       │─── Verify Freshness ────│
  |                                       │    • Check timestamp    │
  |                                       │    • Verify nonce unused│
  |                                       │
  |                                       │─── Regenerate Proof ────│
  |                                       │    • Use received data  │
  |                                       │    • Hash with publicKey│
  |                                       │
  |                                       │─── Compare Proofs ──────│
  |                                       │    • receivedProof ==   │
  |                                       │      regeneratedProof?  │
  |                                       │
  |                                       │─── Accept/Reject ───────│
  |                                       │    • If match → Accept  │
  |                                       │    • Store timestamp-   │
  |                                       │      nonce to prevent   │
  |                                       │      replay             │
```


# 4. Cryptographic Building Blocks


**Code example;**

```bash
package main

import (
	"encoding/binary"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/sphinxorg/protocol/src/core/hashtree"
	sigproof "github.com/sphinxorg/protocol/src/core/proof"
	key "github.com/sphinxorg/protocol/src/core/sphincs/key/backend"
	sign "github.com/sphinxorg/protocol/src/core/sphincs/sign/backend"

	"github.com/syndtr/goleveldb/leveldb"
)

// Simulating communication between Alice and Charlie with SPHINCS+ signing and verification
func main() {
	// Clear LevelDB directory to avoid stale timestamp-nonce pairs from previous runs
	// For development only; in production, preserve LevelDB to prevent signature reuse
	err := os.RemoveAll("src/core/sphincs/hashtree/leaves_db")
	if err != nil {
		log.Fatal("Failed to clear LevelDB directory:", err)
	}

	// Create the root_hashtree directory
	err = os.MkdirAll("src/core/sphincs/hashtree", os.ModePerm)
	if err != nil {
		log.Fatal("Failed to create hashtree directory:", err)
	}

	// Open LevelDB for local storage of timestamp-nonce pairs
	db, err := leveldb.OpenFile("src/core/sphincs/hashtree/leaves_db", nil)
	if err != nil {
		log.Fatal("Failed to open LevelDB:", err)
	}
	defer db.Close()

	// Initialize the KeyManager with SPHINCS+ parameters
	km, err := key.NewKeyManager()
	if err != nil {
		log.Fatalf("Error initializing KeyManager: %v", err)
	}

	// Initialize SPHINCS parameters
	parameters := km.GetSPHINCSParameters()

	// Initialize SphincsManager for signing and verification
	manager := sign.NewSphincsManager(db, km, parameters)

	// Generate a new SPHINCS key pair
	sk, pk, err := km.GenerateKey()
	if err != nil {
		log.Fatalf("Error generating keys: %v", err)
	}
	fmt.Println("Keys generated successfully!")

	// Serialize the key pair
	skBytes, pkBytes, err := km.SerializeKeyPair(sk, pk)
	if err != nil {
		log.Fatalf("Error serializing key pair: %v", err)
	}
	fmt.Printf("Serialized private key: %x\n", skBytes)
	fmt.Printf("Size of Serialized private key: %d bytes\n", len(skBytes))
	fmt.Printf("Serialized public key: %x\n", pkBytes)
	fmt.Printf("Size of Serialized public key: %d bytes\n", len(pkBytes))

	// Deserialize the key pair
	deserializedSK, deserializedPK, err := km.DeserializeKeyPair(skBytes, pkBytes)
	if err != nil {
		log.Fatalf("Error deserializing key pair: %v", err)
	}
	fmt.Println("Keys deserialized successfully!")

	// Alice signs the message for tx1 = sig1(proof1(m1, nonce, timestamp, root, pk))
	// Signing is performed locally; tx1 may be submitted to a blockchain for on-chain processing
	message := []byte("Hello, world!")
	// SignMessage generates sig1 with timestamp and nonce to prevent reuse
	sig, merkleRoot, timestamp, nonce, err := manager.SignMessage(message, deserializedSK)
	if err != nil {
		log.Fatal("Failed to sign message:", err)
	}

	// Serialize the signature
	sigBytes, err := manager.SerializeSignature(sig)
	if err != nil {
		log.Fatal("Failed to serialize signature:", err)
	}
	fmt.Printf("Signature (sig1): %x\n", sigBytes)
	fmt.Printf("Size of Serialized Signature: %d bytes\n", len(sigBytes))
	fmt.Printf("Timestamp: %x\n", timestamp)
	fmt.Printf("Nonce: %x\n", nonce)

	// Convert Merkle Root Hash to []byte
	merkleRootHash := merkleRoot.Hash.Bytes()
	fmt.Printf("HashTree (Root Hash): %x\n", merkleRootHash)
	fmt.Printf("Size of HashTree (Root Hash): %d bytes\n", len(merkleRootHash))

	// Save Merkle root hash to a file
	err = hashtree.SaveRootHashToFile(merkleRoot, "src/core/sphincs/hashtree/hashtree.bin")
	if err != nil {
		log.Fatal("Failed to save root hash to file:", err)
	}

	// Generate proof1 for tx1
	// Proof1 binds sig1 to m1, timestamp, nonce, root, and pk
	proof, err := sigproof.GenerateSigProof([][]byte{append(timestamp, append(nonce, message...)...)}, [][]byte{merkleRootHash}, pkBytes)
	if err != nil {
		log.Fatalf("Failed to generate signature proof: %v", err)
	}
	fmt.Printf("Generated Proof (proof1): %x\n", proof)

	// Store the proof locally
	sigproof.SetStoredProof(proof)
	fmt.Println("Signature proof stored successfully!")

	// Alice verifies sig1 locally
	isValidSig := manager.VerifySignature(message, timestamp, nonce, sig, deserializedPK, merkleRoot)
	fmt.Printf("Alice verifies signature valid: %v\n", isValidSig)
	if isValidSig {
		fmt.Printf("Signed Message by Alice: %s\n", message)
	}

	// --- Simulate sending tx1 to Charlie ---
	// In a blockchain, tx1 could be submitted to a smart contract for on-chain verification
	receivedPK := pkBytes
	receivedProof := proof
	receivedMessage := message
	receivedTimestamp := timestamp
	receivedNonce := nonce
	receivedMerkleRootHash := merkleRootHash

	// Charlie’s verification for tx1
	// Performed locally; results may be submitted to a blockchain
	// Check timestamp freshness
	receivedTimestampInt := binary.BigEndian.Uint64(receivedTimestamp)
	currentTimestamp := uint64(time.Now().Unix())
	if currentTimestamp-receivedTimestampInt > 300 { // 5-minute window
		log.Fatal("Signature timestamp is too old, possible reuse attempt")
	}

	// Check for signature reuse
	// No pair exists yet, as we store it only after verification
	exists, err := manager.CheckTimestampNonce(receivedTimestamp, receivedNonce)
	if err != nil {
		log.Fatalf("Failed to check timestamp-nonce pair: %v", err)
	}
	if exists {
		log.Fatal("Signature reuse detected: timestamp-nonce pair already exists")
	}

	// Regenerate proof1
	regeneratedProof, err := sigproof.GenerateSigProof([][]byte{append(receivedTimestamp, append(receivedNonce, receivedMessage...)...)}, [][]byte{receivedMerkleRootHash}, receivedPK)
	if err != nil {
		log.Fatalf("Failed to regenerate proof: %v", err)
	}
	fmt.Printf("Regenerated Proof: %x\n", regeneratedProof)

	// Verify proof1
	isValidProof := sigproof.VerifySigProof(receivedProof, regeneratedProof)
	fmt.Printf("Charlie verifies proof valid: %v\n", isValidProof)

	if isValidProof && isValidSig {
		fmt.Printf("Charlie accepts tx1:\n")
		fmt.Printf("Public Key: %x\n", receivedPK)
		fmt.Printf("Proof: %x\n", receivedProof)
		fmt.Printf("Message: %s\n", receivedMessage)
		fmt.Printf("Timestamp: %x (%d)\n", receivedTimestamp, receivedTimestampInt)
		fmt.Printf("Nonce: %x\n", receivedNonce)
		fmt.Printf("RootHash: %x\n", receivedMerkleRootHash)
		totalSize := len(receivedPK) + len(receivedProof) + len(receivedMessage) + len(receivedTimestamp) + len(receivedNonce) + len(receivedMerkleRootHash)
		fmt.Printf("Total Size in Bytes: %d\n", totalSize)
		// In a blockchain, Charlie could submit tx1 to a smart contract for on-chain verification
	} else {
		fmt.Println("Invalid proof or signature for tx1.")
	}

	// Store timestamp-nonce pair only after verification
	// Prevents "Signature reuse detected" error and ensures reuse prevention
	// In a blockchain, this could be stored in a smart contract
	err = manager.StoreTimestampNonce(receivedTimestamp, receivedNonce)
	if err != nil {
		log.Fatal("Failed to store timestamp-nonce pair:", err)
	}

	// --- Simulate Alice attempting tx2 = sig1(proof2(m2, nonce, timestamp, root, pk)) ---
	// Demonstrates that Alice cannot reuse sig1
	message2 := []byte("Hello, world!")
	// Reuse sig1 with proof2
	proof2, err := sigproof.GenerateSigProof([][]byte{append(timestamp, append(nonce, message2...)...)}, [][]byte{merkleRootHash}, pkBytes)
	if err != nil {
		log.Fatalf("Failed to generate proof for tx2: %v", err)
	}
	fmt.Printf("Generated Proof (proof2): %x\n", proof2)

	// Charlie’s verification for tx2
	receivedMessage2 := message2
	receivedProof2 := proof2

	// Check timestamp freshness
	if currentTimestamp-receivedTimestampInt > 300 {
		log.Println("Signature timestamp for tx2 is too old, rejected")
	} else {
		// Check for signature reuse
		// Detects the timestamp-nonce pair stored for tx1
		exists, err = manager.CheckTimestampNonce(receivedTimestamp, receivedNonce)
		if err != nil {
			log.Fatalf("Failed to check timestamp-nonce pair for tx2: %v", err)
		}
		if exists {
			log.Println("Signature reuse detected for tx2: timestamp-nonce pair already exists")
		}

		// Regenerate proof2
		regeneratedProof2, err := sigproof.GenerateSigProof([][]byte{append(receivedTimestamp, append(receivedNonce, receivedMessage2...)...)}, [][]byte{receivedMerkleRootHash}, receivedPK)
		if err != nil {
			log.Fatalf("Failed to regenerate proof for tx2: %v", err)
		}
		fmt.Printf("Regenerated Proof (proof2): %x\n", regeneratedProof2)

		// Verify proof2
		isValidProof2 := sigproof.VerifySigProof(receivedProof2, regeneratedProof2)
		fmt.Printf("Charlie verifies proof (tx2) valid: %v\n", isValidProof2)

		// Verify sig1 for m2 (will fail due to SPHINCS+ binding)
		isValidSig2 := manager.VerifySignature(receivedMessage2, receivedTimestamp, receivedNonce, sig, deserializedPK, merkleRoot)
		fmt.Printf("Charlie verifies signature (tx2) valid: %v\n", isValidSig2)

		if isValidProof2 && isValidSig2 {
			fmt.Println("Charlie accepts tx2 (this should not happen).")
		} else {
			fmt.Println("Invalid proof or signature for tx2, rejected as expected.")
		}
	}
}
```


**The results;**

```bash
[Running] go run "/Users/kusuma/Desktop/protocol/src/core/sphincs/sign/test_sign.go"
2026/02/23 15:56:48 GenerateKey: Generated keys: SKseed=16, SKprf=16, PKseed=16, PKroot=16, PKseed(pub)=16, PKroot(pub)=16
2026/02/23 15:56:48 SerializeSK: Serialized private key: length=64
2026/02/23 15:56:48 SerializeKeyPair: Serialized keys: PrivateKey length=64, PublicKey length=32
2026/02/23 15:56:48 DeserializeKeyPair: PrivateKey length=64, PublicKey length=32
2026/02/23 15:56:48 DeserializeKeyPair: Successfully deserialized keys: SKseed=16, SKprf=16, PKseed=16, PKroot=16
Keys generated successfully!
Serialized private key: 4e323acb156b7f903d5de4821a78fd953b39ca710f951f4cb988f2fe9390508c8591b3d5aff0df64ac468a44c20e2c278194b5d2a7f9d56fa04b844bd21f3e34
Size of Serialized private key: 64 bytes
Serialized public key: 8591b3d5aff0df64ac468a44c20e2c278194b5d2a7f9d56fa04b844bd21f3e34
Size of Serialized public key: 32 bytes
Keys deserialized successfully!
Signature (sig1): 393ace7409921745b383fef39d9f409d4f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e344f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358097b4dda6fad468a1488554d31c3f338194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858097b4dda6fad468a1488554d31c3f338194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858097b4dda6fad468a1488554d31c3f338194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858097b4dda6fad468a1488554d31c3f338194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858097b4dda6fad468a1488554d31c3f338194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858097b4dda6fad468a1488554d31c3f338194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d358695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858695b6d3a8f8d66ea74a874acd1e3d354f3039cf106d78983457ef8e1776f2858097b4dda6fad468a1488554d31c3f338194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e348194b5d2a7f9d56fa04b844bd21f3e34
Size of Serialized Signature: 7856 bytes
Timestamp: 00000000699c1650
Nonce: dae3896957920bd7b2d495513cc85345
HashTree (Root Hash): eaf138e95f0e120bb768c2cd0989da60d123f7eafa905abbfb41dbf6498e8776
Size of HashTree (Root Hash): 32 bytes
Generated Proof (proof1): 31ccd36b9e5d18a9dba8b93a6852a40e32b83f83ef41d4b76f8d8298d5857f8b
Signature proof stored successfully!
Alice verifies signature valid: true
Signed Message by Alice: Hello, world!
Regenerated Proof: 31ccd36b9e5d18a9dba8b93a6852a40e32b83f83ef41d4b76f8d8298d5857f8b
Charlie verifies proof valid: true
Charlie accepts tx1:
Public Key: 8591b3d5aff0df64ac468a44c20e2c278194b5d2a7f9d56fa04b844bd21f3e34
Proof: 31ccd36b9e5d18a9dba8b93a6852a40e32b83f83ef41d4b76f8d8298d5857f8b
Message: Hello, world!
Timestamp: 00000000699c1650 (1771837008)
Nonce: dae3896957920bd7b2d495513cc85345
RootHash: eaf138e95f0e120bb768c2cd0989da60d123f7eafa905abbfb41dbf6498e8776
Total Size in Bytes: 133
Generated Proof (proof2): 31ccd36b9e5d18a9dba8b93a6852a40e32b83f83ef41d4b76f8d8298d5857f8b
2026/02/23 15:56:53 Signature reuse detected for tx2: timestamp-nonce pair already exists
Regenerated Proof (proof2): 31ccd36b9e5d18a9dba8b93a6852a40e32b83f83ef41d4b76f8d8298d5857f8b
Charlie verifies proof (tx2) valid: true
Charlie verifies signature (tx2) valid: true
Charlie accepts tx2 (this should not happen).

[Done] exited with code=0 in 10.25 seconds

```

### 1. Signature Generation

This process is happening on Alice's local device that will generated ```Size of Serialized Signature: 7856 bytes```, the idea is how not to transmitted or dumping this magnitude signature size out of alice's device, instead, alice can created compact proof of her signature then transmitted the proof to charlie along with another metadata.


![](https://github.com/sphinxorg/SIPS/blob/main/.github/workflows/sips0011/HashTree%20scheme.png)

* Signature original Size: ~7KB
* Purpose: Reduce signature size from ~7KB to 32-byte hash
* Property: Every single bytes of Root is absolutely come from SPHINCS+


### 2. Signature Verification

This process is happening on Charlie's local device, charlie Complete Verification Without Signature:

* Charlie never needs the actual ~7KB SPHINCS+ signature
* Charlie only needs: message, timestamp, nonce, merkle root, and Alice's public key
* The proof itself is just a 32-byte hash

![](https://github.com/sphinxorg/SIPS/blob/main/.github/workflows/sips0011/HashTree%20scheme-3.png)


The Example of verification main function is actually secure:

```bash
if isValidProof && isValidSig {
    fmt.Printf("Charlie accepts tx1:\n")
    // Charlie accepts the transaction!
}
```

Even though ```isValidSig``` comes from Alice's local verification, Charlie is NOT relying on it for security. Charlie's acceptance is based on:

Proof verification (```isValidProof```) - This proves Alice has:

* The correct message
* A valid timestamp-nonce pair
* The correct merkle root
* Alice's public key

The cryptographic properties of the proof guarantee that only someone with the actual signature could have generated it

### 2. Merkle Tree Construction

The signature is split into 4 equal parts, each becoming a leaf in a Merkle tree:

```bash
Signature (7KB) → [Part1][Part2][Part3][Part4] → Merkle Tree → Root Hash (32 bytes
```


### 3. Proof Generation

The proof is a hash that binds all components:

```bash
Proof = H( timestamp ‖ nonce ‖ message ‖ merkleRoot ‖ publicKey )
```

### 4. Trust Model

**What Charlie KNOWS:**
- receivedPK        // Alice's public key (trusted)
- receivedProof     // The proof from Alice
- receivedMessage   // The message
- receivedTimestamp // Fresh timestamp
- receivedNonce     // Unique nonce
- receivedMerkleRootHash // Root of signature Merkle tree

**What Charlie VERIFIES:**
1. Timestamp is fresh (prevents replay)
2. Timestamp-nonce pair is unused (prevents replay)
3. Regenerated proof matches received proof (proves Alice has valid signature)


**The size savings are excellent - Charlie only needs to handle:**
* Public key: ~32 bytes
* Proof: 32 bytes (hash)
* Message: variable
* Timestamp: 8 bytes
* Nonce: 16 bytes
* Merkle root: 32 bytes
* Total: ~120 bytes + message size, instead of  ~7KB for only original signature!